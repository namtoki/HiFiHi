# Auracast Assistant + AWSãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰é–‹ç™ºè¨­è¨ˆæ›¸ v2

Flutterï¼ˆAndroidå„ªå…ˆï¼‰ã§Auracast Assistantã‚¢ãƒ—ãƒªã‚’é–‹ç™ºã—ã€AWSãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ï¼ˆæ±äº¬ãƒªãƒ¼ã‚¸ãƒ§ãƒ³ ap-northeast-1ï¼‰ã¨é€£æºã™ã‚‹ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®åŒ…æ‹¬çš„ãªæŠ€è¡“è¨­è¨ˆãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã™ã€‚

**æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ**: Airoha SDKã«ä¾å­˜ã›ãšã€Androidæ¨™æº–BLE API + æ¥ç¶šæ¸ˆã¿ã‚¤ãƒ¤ãƒ›ãƒ³å´ã®BASSï¼ˆBroadcast Audio Scan Serviceï¼‰GATTã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ç”¨ã—ã¦ã‚¢ãƒ—ãƒªå†…å®Œçµã§å®Ÿè£…ã—ã¾ã™ã€‚

---

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£å…¨ä½“åƒ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      AURACAST ASSISTANT ARCHITECTURE                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ MOBILE (Flutter)                                                            â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚ â”‚   UI Layer   â”‚  â”‚   Riverpod   â”‚  â”‚Method Channelâ”‚  â”‚    Hive      â”‚    â”‚
â”‚ â”‚ Material 3   â”‚â—„â”€â”¤    State     â”‚â—„â”€â”¤ Native BLE   â”‚  â”‚Local Storage â”‚    â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ANDROID NATIVE (Kotlin)                                                     â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚  BluetoothLeScanner    â”‚  GATT Client (BASS)  â”‚  PA Sync Manager    â”‚   â”‚
â”‚ â”‚  Broadcast Discovery   â”‚  Add Source to Sink  â”‚  BIG Sync Control   â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ AWS BACKEND (ap-northeast-1)                                                â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚ â”‚ CloudFront   â”‚  â”‚ API Gateway  â”‚  â”‚   AppSync    â”‚  â”‚   Cognito    â”‚    â”‚
â”‚ â”‚ + S3 Static  â”‚  â”‚  REST API    â”‚  â”‚   GraphQL    â”‚  â”‚  User Auth   â”‚    â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚        â”‚                 â”‚                 â”‚                 â”‚              â”‚
â”‚        â–¼                 â–¼                 â–¼                 â–¼              â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚ â”‚    Lambda    â”‚  â”‚  DynamoDB    â”‚  â”‚   Kinesis    â”‚  â”‚ Personalize  â”‚    â”‚
â”‚ â”‚  Functions   â”‚  â”‚ Single-Table â”‚  â”‚  Firehose    â”‚  â”‚   ML Recs    â”‚    â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 1. Bluetooth LE Audio å®Ÿè£…ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### 1.1 é‡è¦ãªåŒºåˆ¥ï¼šã‚·ã‚¹ãƒ†ãƒ BASS vs ã‚¤ãƒ¤ãƒ›ãƒ³å´BASS

Android 13ä»¥é™ã€`BluetoothLeBroadcastAssistant`ï¼ˆã‚·ã‚¹ãƒ†ãƒ ãƒ¬ãƒ™ãƒ«ã®Broadcast Assistant APIï¼‰ã¯ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ—ãƒªã®ã¿ã«åˆ¶é™ã•ã‚Œã¦ã„ã¾ã™ã€‚**ã—ã‹ã—**ã€ã“ã‚Œã¯æ¥ç¶šæ¸ˆã¿ã‚¤ãƒ¤ãƒ›ãƒ³ï¼ˆSinkï¼‰å´ã®BASS GATTã‚µãƒ¼ãƒ“ã‚¹ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹åˆ¶é™ã¨ã¯ç•°ãªã‚Šã¾ã™ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         BASS ã‚¢ã‚¯ã‚»ã‚¹ã®åŒºåˆ¥                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  âŒ BluetoothLeBroadcastAssistant API (ã‚·ã‚¹ãƒ†ãƒ ãƒ¬ãƒ™ãƒ«)                       â”‚
â”‚     - Android 13+ ã§ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¢ãƒ—ãƒªã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ä¸å¯                       â”‚
â”‚     - ã‚·ã‚¹ãƒ†ãƒ UIãŒä½¿ç”¨                                                       â”‚
â”‚                                                                             â”‚
â”‚  âœ… ã‚¤ãƒ¤ãƒ›ãƒ³å´ BASS GATT Service (ãƒ‡ãƒã‚¤ã‚¹ãƒ¬ãƒ™ãƒ«)                            â”‚
â”‚     - æ¥ç¶šæ¸ˆã¿BLEãƒ‡ãƒã‚¤ã‚¹ã®GATTã‚µãƒ¼ãƒ“ã‚¹ã¨ã—ã¦å…¬é–‹                             â”‚
â”‚     - æ¨™æº–BluetoothGatt APIã§ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½                                   â”‚
â”‚     - ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¢ãƒ—ãƒªã‹ã‚‰æ“ä½œå¯èƒ½                                        â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æœ¬è¨­è¨ˆã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ã‚¢ãƒ—ãƒªå†…å®Œçµã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚   â”‚  Broadcast  â”‚      â”‚   Denon     â”‚      â”‚  Denon TWS  â”‚                â”‚
â”‚   â”‚   Source    â”‚ â”€â”€â”€â–º â”‚    App      â”‚ â”€â”€â”€â–º â”‚  (Sink)     â”‚                â”‚
â”‚   â”‚  (Auracast) â”‚      â”‚ (Assistant) â”‚      â”‚             â”‚                â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚         â”‚                    â”‚                    â”‚                         â”‚
â”‚         â”‚                    â”‚                    â”‚                         â”‚
â”‚    Extended ADV         GATTçµŒç”±ã§           BASS GATT                      â”‚
â”‚    (BAAS UUID)          æ¥ç¶šæŒ‡ç¤º             Service                        â”‚
â”‚                                                                             â”‚
â”‚   å‡¦ç†ãƒ•ãƒ­ãƒ¼:                                                                â”‚
â”‚   1. ã‚¹ã‚­ãƒ£ãƒ³: BluetoothLeScanner + ScanFilter (BAAS UUID: 0x1852)          â”‚
â”‚   2. é¸æŠUI: ã‚¢ãƒ—ãƒªå†…ã§ç‹¬è‡ªUIè¡¨ç¤º                                            â”‚
â”‚   3. æ¥ç¶šæŒ‡ç¤º: ã‚¤ãƒ¤ãƒ›ãƒ³å´BASS GATTã®Control PointçµŒç”±                        â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.3 API Levelè¦ä»¶

| æ©Ÿèƒ½ | æœ€å°API Level | å¯¾å¿œAndroid | å‚™è€ƒ |
|------|---------------|-------------|------|
| LE Audio Protocol Stack | API 33 | Android 13 | åŸºç›¤ã‚µãƒãƒ¼ãƒˆ |
| BluetoothLeScanner (Extended ADV) | API 26+ | Android 8+ | setLegacy(false)å¿…é ˆ |
| GATT Client | API 21+ | Android 5+ | æ¨™æº–BLE API |
| Auracast Broadcastæ¤œå‡º | API 33+ | Android 13+ | ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ä¾å­˜ |

### 1.4 AndroidManifest.xmlè¨­å®š

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- Android 12+ Bluetooth permissions -->
    <uses-permission android:name="android.permission.BLUETOOTH_SCAN"
                     android:usesPermissionFlags="neverForLocation" />
    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
    
    <!-- Legacy permissions (Android 11 and below) -->
    <uses-permission android:name="android.permission.BLUETOOTH"
                     android:maxSdkVersion="30" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN"
                     android:maxSdkVersion="30" />
    
    <!-- Hardware features -->
    <uses-feature android:name="android.hardware.bluetooth_le" android:required="true"/>
</manifest>
```

---

## 2. Bluetooth SIG AuracastæŠ€è¡“ä»•æ§˜

### 2.1 Public Broadcast Profile (PBP) v1.0.1

**å½¹å‰²å®šç¾©:**

| å½¹å‰² | ç•¥ç§° | èª¬æ˜ |
|------|------|------|
| Public Broadcast Source | PBS | ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆã‚’é€ä¿¡ãƒ»ã‚¢ãƒŠã‚¦ãƒ³ã‚¹ |
| Public Broadcast Sink | PBK | ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆéŸ³å£°ã‚’å—ä¿¡ãƒ»å†ç”Ÿ |
| Public Broadcast Assistant | PBA | ã‚·ãƒ³ã‚¯ãƒ‡ãƒã‚¤ã‚¹ã®æ¥ç¶šã‚’åˆ¶å¾¡ï¼ˆæœ¬ã‚¢ãƒ—ãƒªã®å½¹å‰²ï¼‰ |

### 2.2 BASS (Broadcast Audio Scan Service) ä»•æ§˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BASS GATT Service Structure                               â”‚
â”‚                    UUID: 0x184F                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  Characteristics:                                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Broadcast Audio Scan Control Point (BASCP)                         â”‚     â”‚
â”‚  â”‚ UUID: 0x2BC7                                                       â”‚     â”‚
â”‚  â”‚ Properties: Write                                                  â”‚     â”‚
â”‚  â”‚ Operations:                                                        â”‚     â”‚
â”‚  â”‚   - 0x00: Remote Scan Stopped                                      â”‚     â”‚
â”‚  â”‚   - 0x01: Remote Scan Started                                      â”‚     â”‚
â”‚  â”‚   - 0x02: Add Source                                               â”‚     â”‚
â”‚  â”‚   - 0x03: Modify Source                                            â”‚     â”‚
â”‚  â”‚   - 0x04: Set Broadcast_Code                                       â”‚     â”‚
â”‚  â”‚   - 0x05: Remove Source                                            â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Broadcast Receive State                                            â”‚     â”‚
â”‚  â”‚ UUID: 0x2BC8                                                       â”‚     â”‚
â”‚  â”‚ Properties: Read, Notify                                           â”‚     â”‚
â”‚  â”‚ Contents:                                                          â”‚     â”‚
â”‚  â”‚   - Source_ID (1 octet)                                            â”‚     â”‚
â”‚  â”‚   - Source_Address_Type (1 octet)                                  â”‚     â”‚
â”‚  â”‚   - Source_Address (6 octets)                                      â”‚     â”‚
â”‚  â”‚   - Source_Adv_SID (1 octet)                                       â”‚     â”‚
â”‚  â”‚   - Broadcast_ID (3 octets)                                        â”‚     â”‚
â”‚  â”‚   - PA_Sync_State (1 octet)                                        â”‚     â”‚
â”‚  â”‚   - BIG_Encryption (1 octet)                                       â”‚     â”‚
â”‚  â”‚   - Num_Subgroups + BIS_Sync_State per subgroup                    â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 Add Source Operation ãƒ‡ãƒ¼ã‚¿æ§‹é€ 

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Add Source (Opcode 0x02) Payload                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  Offset  Size   Field                    Description                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€  â”€â”€â”€â”€   â”€â”€â”€â”€â”€                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                        â”‚
â”‚  0       1      Opcode                   0x02 (Add Source)                  â”‚
â”‚  1       1      Advertiser_Address_Type  0x00=Public, 0x01=Random           â”‚
â”‚  2       6      Advertiser_Address       Broadcast Source BT Address        â”‚
â”‚  8       1      Advertising_SID          SID from Extended ADV (0x00-0x0F)  â”‚
â”‚  9       3      Broadcast_ID             24-bit Broadcast identifier        â”‚
â”‚  12      1      PA_Sync                  0x00=No sync, 0x01=Sync to PA      â”‚
â”‚  13      2      PA_Interval              PA interval (1.25ms units)         â”‚
â”‚  15      1      Num_Subgroups            Number of subgroups to sync        â”‚
â”‚  16+     var    Subgroup entries         BIS_Sync (4) + Metadata_Len (1)    â”‚
â”‚                                          + Metadata (var) per subgroup      â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.4 BASE (Broadcast Audio Source Endpoint) ãƒ‡ãƒ¼ã‚¿æ§‹é€ 

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LEVEL 1: Broadcast Source (BIG Level)                                       â”‚
â”‚ â”œâ”€â”€ Presentation_Delay (3 octets) - ãƒã‚¤ã‚¯ãƒ­ç§’å˜ä½                          â”‚
â”‚ â”œâ”€â”€ Num_Subgroups (1 octet) - 1-255                                        â”‚
â”‚ â””â”€â”€ Subgroup entries...                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ LEVEL 2: Subgroups (å…±æœ‰ã‚³ãƒ¼ãƒ‡ãƒƒã‚¯è¨­å®š/ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿)                           â”‚
â”‚ â”œâ”€â”€ Num_BIS (1 octet)                                                      â”‚
â”‚ â”œâ”€â”€ Codec_ID (5 octets) - LC3: 0x06                                        â”‚
â”‚ â”œâ”€â”€ Codec_Specific_Configuration (LTV)                                      â”‚
â”‚ â”œâ”€â”€ Metadata (LTV)                                                          â”‚
â”‚ â””â”€â”€ BIS entries...                                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ LEVEL 3: BIS (å€‹åˆ¥ã‚¹ãƒˆãƒªãƒ¼ãƒ è¨­å®š)                                            â”‚
â”‚ â”œâ”€â”€ BIS_index (1 octet) - 1-31                                              â”‚
â”‚ â””â”€â”€ Codec_Specific_Configuration (LTV)                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.5 ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿LTVå½¢å¼

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Length â”‚  Type  â”‚     Value       â”‚
â”‚ 1 byte â”‚ 1 byte â”‚ (Length-1) bytesâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä¸»è¦ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ—:**

| Type Code | åç§° | èª¬æ˜ |
|-----------|------|------|
| 0x01 | Preferred_Audio_Contexts | 16-bit Context Type |
| 0x02 | Streaming_Audio_Contexts | 16-bit Context Type |
| 0x03 | Program_Info | UTF-8æ–‡å­—åˆ—ï¼ˆç•ªçµ„æƒ…å ±ï¼‰ |
| 0x04 | Language | ISO 639-3è¨€èªã‚³ãƒ¼ãƒ‰ |
| 0x0C | Broadcast_Name | UTF-8æ–‡å­—åˆ—ï¼ˆ4-32æ–‡å­—ï¼‰ |

### 2.6 Broadcast_ID / Broadcast Codeä»•æ§˜

```
Broadcast_ID: 3 bytes (24 bits) - BIGã‚’ä¸€æ„ã«è­˜åˆ¥ã™ã‚‹ãƒ©ãƒ³ãƒ€ãƒ å€¤

Broadcast_Code: 16 octets (128 bits) - æš—å·åŒ–ã‚­ãƒ¼
- ASCIIæ–‡å­—åˆ—ï¼ˆUTF-8ï¼‰ã€æœ«å°¾ã‚¼ãƒ­ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
- ä¾‹: "GymTime$2day" â†’ 0x47 0x79 0x6D... 0x00 0x00 0x00 0x00

æš—å·åŒ–ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : AES-CCM (128-bit key)
MIC (Message Integrity Check): 4 bytes
```

---

## 3. ç”»é¢é·ç§»ãƒ•ãƒ­ãƒ¼

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 1: ã‚¤ãƒ¤ãƒ›ãƒ³æ¥ç¶šæ¸ˆã¿çŠ¶æ…‹                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                                        â”‚
â”‚  â”‚  â”‚      ğŸ§ Denon TWS         â”‚  â”‚                                        â”‚
â”‚  â”‚  â”‚      æ¥ç¶šæ¸ˆã¿              â”‚  â”‚                                        â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                                        â”‚
â”‚  â”‚                                 â”‚                                        â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                                        â”‚
â”‚  â”‚  â”‚  ğŸ”Š Auracast              â”‚  â”‚  â† ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¿ãƒƒãƒ—                     â”‚
â”‚  â”‚  â”‚  ã€Œå‘¨å›²ã®æ”¾é€ã‚’æ¢ã™ã€       â”‚  â”‚                                        â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 2: ã‚¹ã‚­ãƒ£ãƒ³ä¸­ï¼ˆã‚¢ãƒ—ãƒªå†…UIï¼‰                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚  â”‚  â† Auracastæ”¾é€                â”‚                                         â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚                                        â”‚
â”‚  â”‚                                 â”‚                                        â”‚
â”‚  â”‚  å‘¨å›²ã®ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆã‚’æ¤œç´¢ä¸­... â”‚                                        â”‚
â”‚  â”‚         â—  â—¡ â—                   â”‚   BluetoothLeScanner                   â”‚
â”‚  â”‚                                 â”‚   + ScanFilter (UUID 0x1852)           â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚                                        â”‚
â”‚  â”‚  åˆ©ç”¨å¯èƒ½ãªæ”¾é€:                 â”‚                                        â”‚
â”‚  â”‚                                 â”‚                                        â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                                        â”‚
â”‚  â”‚  â”‚ ğŸ“» Cafe Jazz BGM          â”‚  â”‚  â† Extended ADVã‹ã‚‰æ¤œå‡º                â”‚
â”‚  â”‚  â”‚    -45dBm | LC3 48kHz     â”‚  â”‚                                        â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                                        â”‚
â”‚  â”‚                                 â”‚                                        â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                                        â”‚
â”‚  â”‚  â”‚ ğŸ“» Museum Audio Guide     â”‚  â”‚                                        â”‚
â”‚  â”‚  â”‚    -62dBm | LC3 24kHz     â”‚  â”‚                                        â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“ ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒé¸æŠ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 3: æ¥ç¶šå‡¦ç†ï¼ˆã‚¢ãƒ—ãƒªå†…ï¼‰                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚  â”‚                                 â”‚                                        â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚    å‡¦ç†å†…å®¹:                           â”‚
â”‚  â”‚   â”‚                         â”‚   â”‚    1. TWSå´BASS GATTã«æ¥ç¶š             â”‚
â”‚  â”‚   â”‚  "Cafe Jazz BGM" ã«     â”‚   â”‚    2. BASCP Write (Add Source)        â”‚
â”‚  â”‚   â”‚   æ¥ç¶šä¸­...              â”‚   â”‚    3. PA Syncç¢ºç«‹                     â”‚
â”‚  â”‚   â”‚                         â”‚   â”‚    4. BIG Syncç¢ºç«‹                    â”‚
â”‚  â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚    5. BISå—ä¿¡é–‹å§‹                     â”‚
â”‚  â”‚   â”‚  â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ 80%   â”‚   â”‚   â”‚                                       â”‚
â”‚  â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚                                       â”‚
â”‚  â”‚   â”‚                         â”‚   â”‚                                       â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚                                        â”‚
â”‚  â”‚                                 â”‚                                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“ æ¥ç¶šå®Œäº†
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 4: å†ç”Ÿä¸­                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                                        â”‚
â”‚  â”‚  â”‚      ğŸ§ Denon TWS         â”‚  â”‚                                        â”‚
â”‚  â”‚  â”‚      æ¥ç¶šæ¸ˆã¿              â”‚  â”‚                                        â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                                        â”‚
â”‚  â”‚                                 â”‚                                        â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                                        â”‚
â”‚  â”‚  â”‚  ğŸ”Š ç¾åœ¨ã®éŸ³å£°ã‚½ãƒ¼ã‚¹:      â”‚  â”‚                                        â”‚
â”‚  â”‚  â”‚  ğŸ“» Cafe Jazz BGM        â”‚  â”‚  â† BASS Receive Stateç›£è¦–              â”‚
â”‚  â”‚  â”‚                           â”‚  â”‚                                        â”‚
â”‚  â”‚  â”‚  â–¶ï¸ å†ç”Ÿä¸­ | LC3 48kHz    â”‚  â”‚                                        â”‚
â”‚  â”‚  â”‚                           â”‚  â”‚                                        â”‚
â”‚  â”‚  â”‚     [åˆ‡æ–­ã™ã‚‹]            â”‚  â”‚                                        â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ 

### 4.1 Flutter ã‚¢ãƒ—ãƒªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 

```
auracast_assistant/
â”œâ”€â”€ android/
â”‚   â””â”€â”€ app/src/main/kotlin/com/denon/auracast/
â”‚       â”œâ”€â”€ MainActivity.kt
â”‚       â”œâ”€â”€ bluetooth/
â”‚       â”‚   â”œâ”€â”€ AuracastScanner.kt         # Broadcast Sourceæ¤œå‡º
â”‚       â”‚   â”œâ”€â”€ BassGattManager.kt         # BASS GATTæ“ä½œ
â”‚       â”‚   â”œâ”€â”€ BroadcastSourceParser.kt   # ADVãƒ‡ãƒ¼ã‚¿ãƒ‘ãƒ¼ã‚¹
â”‚       â”‚   â””â”€â”€ models/
â”‚       â”‚       â”œâ”€â”€ BroadcastSource.kt
â”‚       â”‚       â”œâ”€â”€ BaseData.kt
â”‚       â”‚       â””â”€â”€ BassState.kt
â”‚       â””â”€â”€ plugins/
â”‚           â””â”€â”€ AuracastPlugin.kt
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ main.dart
â”‚   â”œâ”€â”€ app.dart
â”‚   â”‚
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ constants/
â”‚   â”‚   â”‚   â”œâ”€â”€ api_constants.dart
â”‚   â”‚   â”‚   â””â”€â”€ bluetooth_uuids.dart
â”‚   â”‚   â”œâ”€â”€ di/
â”‚   â”‚   â”‚   â””â”€â”€ injection.dart
â”‚   â”‚   â”œâ”€â”€ error/
â”‚   â”‚   â”‚   â”œâ”€â”€ failures.dart
â”‚   â”‚   â”‚   â””â”€â”€ exceptions.dart
â”‚   â”‚   â””â”€â”€ theme/
â”‚   â”‚       â””â”€â”€ app_theme.dart
â”‚   â”‚
â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”‚   â”œâ”€â”€ local/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ broadcast_local_datasource.dart
â”‚   â”‚   â”‚   â””â”€â”€ remote/
â”‚   â”‚   â”‚       â””â”€â”€ broadcast_remote_datasource.dart
â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”œâ”€â”€ broadcast_source_model.dart
â”‚   â”‚   â”‚   â””â”€â”€ sink_device_model.dart
â”‚   â”‚   â””â”€â”€ repositories/
â”‚   â”‚       â””â”€â”€ auracast_repository_impl.dart
â”‚   â”‚
â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â”œâ”€â”€ broadcast_source.dart
â”‚   â”‚   â”‚   â””â”€â”€ sink_device.dart
â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â””â”€â”€ auracast_repository.dart
â”‚   â”‚   â””â”€â”€ usecases/
â”‚   â”‚       â”œâ”€â”€ scan_broadcasts.dart
â”‚   â”‚       â”œâ”€â”€ add_source_to_sink.dart
â”‚   â”‚       â””â”€â”€ remove_source.dart
â”‚   â”‚
â”‚   â”œâ”€â”€ presentation/
â”‚   â”‚   â”œâ”€â”€ providers/
â”‚   â”‚   â”‚   â”œâ”€â”€ auracast_provider.dart
â”‚   â”‚   â”‚   â””â”€â”€ sink_device_provider.dart
â”‚   â”‚   â”œâ”€â”€ screens/
â”‚   â”‚   â”‚   â”œâ”€â”€ broadcast_list/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ broadcast_list_screen.dart
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ widgets/
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ broadcast_card.dart
â”‚   â”‚   â”‚   â””â”€â”€ playback/
â”‚   â”‚   â”‚       â””â”€â”€ playback_screen.dart
â”‚   â”‚   â””â”€â”€ widgets/
â”‚   â”‚       â””â”€â”€ connection_status.dart
â”‚   â”‚
â”‚   â””â”€â”€ services/
â”‚       â””â”€â”€ auracast_channel.dart
â”‚
â”œâ”€â”€ test/
â””â”€â”€ pubspec.yaml
```

### 4.2 AWS CDK ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£æ§‹é€ 

```
infrastructure/
â”œâ”€â”€ bin/
â”‚   â””â”€â”€ infrastructure.ts
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ stacks/
â”‚   â”‚   â”œâ”€â”€ api-stack.ts
â”‚   â”‚   â”œâ”€â”€ database-stack.ts
â”‚   â”‚   â”œâ”€â”€ auth-stack.ts
â”‚   â”‚   â””â”€â”€ analytics-stack.ts
â”‚   â””â”€â”€ constructs/
â”‚       â”œâ”€â”€ lambda-api.ts
â”‚       â””â”€â”€ dynamodb-table.ts
â”œâ”€â”€ lambda/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ broadcasts/
â”‚   â”‚   â”‚   â”œâ”€â”€ get.py
â”‚   â”‚   â”‚   â”œâ”€â”€ list.py
â”‚   â”‚   â”‚   â””â”€â”€ create.py
â”‚   â”‚   â””â”€â”€ shared/
â”‚   â”‚       â””â”€â”€ db.py
â”‚   â””â”€â”€ analytics/
â”‚       â””â”€â”€ transform.py
â”œâ”€â”€ graphql/
â”‚   â”œâ”€â”€ schema.graphql
â”‚   â””â”€â”€ resolvers/
â””â”€â”€ package.json
```

---

## 5. Kotlinå®Ÿè£…ã‚³ãƒ¼ãƒ‰

### 5.1 Bluetooth UUIDså®šç¾©

```kotlin
// bluetooth/BluetoothUuids.kt
package com.denon.auracast.bluetooth

import android.os.ParcelUuid
import java.util.UUID

object BluetoothUuids {
    // Broadcast Audio Announcement Service (ã‚¹ã‚­ãƒ£ãƒ³ç”¨)
    val BROADCAST_AUDIO_ANNOUNCEMENT_SERVICE: ParcelUuid = 
        ParcelUuid.fromString("00001852-0000-1000-8000-00805F9B34FB")
    
    // Broadcast Audio Scan Service (ã‚¤ãƒ¤ãƒ›ãƒ³å´GATT)
    val BASS_SERVICE: UUID = 
        UUID.fromString("0000184F-0000-1000-8000-00805F9B34FB")
    
    // BASS Characteristics
    val BROADCAST_AUDIO_SCAN_CONTROL_POINT: UUID = 
        UUID.fromString("00002BC7-0000-1000-8000-00805F9B34FB")
    
    val BROADCAST_RECEIVE_STATE: UUID = 
        UUID.fromString("00002BC8-0000-1000-8000-00805F9B34FB")
    
    // Client Characteristic Configuration Descriptor
    val CCCD: UUID = 
        UUID.fromString("00002902-0000-1000-8000-00805F9B34FB")
}
```

### 5.2 Broadcast Source ã‚¹ã‚­ãƒ£ãƒŠãƒ¼

```kotlin
// bluetooth/AuracastScanner.kt
package com.denon.auracast.bluetooth

import android.bluetooth.BluetoothAdapter
import android.bluetooth.le.*
import android.os.Build
import android.os.ParcelUuid
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow

data class DiscoveredBroadcast(
    val address: String,
    val addressType: Int,
    val name: String?,
    val rssi: Int,
    val broadcastId: Int,          // 24-bit Broadcast_ID
    val advertisingSid: Int,        // ADV SID (0x00-0x0F)
    val baseData: ByteArray?,       // BASE data from PA (if available)
    val isEncrypted: Boolean
)

class AuracastScanner(
    private val bluetoothAdapter: BluetoothAdapter
) {
    private var scanner: BluetoothLeScanner? = null
    private var scanCallback: ScanCallback? = null

    fun startScan(): Flow<DiscoveredBroadcast> = callbackFlow {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {
            close(IllegalStateException("LE Audio requires Android 13+"))
            return@callbackFlow
        }

        scanner = bluetoothAdapter.bluetoothLeScanner

        val filter = ScanFilter.Builder()
            .setServiceUuid(BluetoothUuids.BROADCAST_AUDIO_ANNOUNCEMENT_SERVICE)
            .build()

        val settings = ScanSettings.Builder()
            .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)
            .setLegacy(false)  // Extended Advertisingå¯¾å¿œå¿…é ˆ
            .setPhy(ScanSettings.PHY_LE_ALL_SUPPORTED)
            .build()

        scanCallback = object : ScanCallback() {
            override fun onScanResult(callbackType: Int, result: ScanResult) {
                parseBroadcastSource(result)?.let { broadcast ->
                    trySend(broadcast)
                }
            }

            override fun onScanFailed(errorCode: Int) {
                close(ScanException("Scan failed with error: $errorCode"))
            }
        }

        scanner?.startScan(listOf(filter), settings, scanCallback)

        awaitClose {
            stopScan()
        }
    }

    fun stopScan() {
        scanCallback?.let { callback ->
            scanner?.stopScan(callback)
        }
        scanCallback = null
    }

    private fun parseBroadcastSource(result: ScanResult): DiscoveredBroadcast? {
        val record = result.scanRecord ?: return null
        
        // Service Data from Broadcast Audio Announcement
        val serviceData = record.getServiceData(
            BluetoothUuids.BROADCAST_AUDIO_ANNOUNCEMENT_SERVICE
        ) ?: return null

        if (serviceData.size < 4) return null

        // Parse Broadcast Audio Announcement Service Data
        // Format: Broadcast_ID (3 bytes) + Public Broadcast Announcement features (1 byte)
        val broadcastId = (serviceData[0].toInt() and 0xFF) or
                         ((serviceData[1].toInt() and 0xFF) shl 8) or
                         ((serviceData[2].toInt() and 0xFF) shl 16)
        
        val pbpFeatures = serviceData[3].toInt() and 0xFF
        val isEncrypted = (pbpFeatures and 0x01) != 0

        return DiscoveredBroadcast(
            address = result.device.address,
            addressType = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                result.device.addressType
            } else 0,
            name = record.deviceName,
            rssi = result.rssi,
            broadcastId = broadcastId,
            advertisingSid = result.advertisingSid,
            baseData = null,  // PA Syncã§å–å¾—
            isEncrypted = isEncrypted
        )
    }
}

class ScanException(message: String) : Exception(message)
```

### 5.3 BASS GATT Manager

```kotlin
// bluetooth/BassGattManager.kt
package com.denon.auracast.bluetooth

import android.bluetooth.*
import android.content.Context
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import java.util.concurrent.ConcurrentHashMap

sealed class BassState {
    object Disconnected : BassState()
    object Connecting : BassState()
    object Connected : BassState()
    data class SourceAdded(val sourceId: Int) : BassState()
    data class Synced(val sourceId: Int, val bisIndices: List<Int>) : BassState()
    data class Error(val message: String) : BassState()
}

data class BroadcastReceiveState(
    val sourceId: Int,
    val sourceAddress: String,
    val sourceAddressType: Int,
    val advertisingSid: Int,
    val broadcastId: Int,
    val paSyncState: PaSyncState,
    val bigEncryption: BigEncryption,
    val subgroups: List<SubgroupState>
)

enum class PaSyncState(val value: Int) {
    NOT_SYNCED(0x00),
    SYNC_INFO_REQUEST(0x01),
    SYNCED(0x02),
    FAILED(0x03),
    NO_PAST(0x04);
    
    companion object {
        fun fromValue(value: Int) = values().find { it.value == value } ?: NOT_SYNCED
    }
}

enum class BigEncryption(val value: Int) {
    NOT_ENCRYPTED(0x00),
    BROADCAST_CODE_REQUIRED(0x01),
    DECRYPTING(0x02),
    BAD_CODE(0x03);
    
    companion object {
        fun fromValue(value: Int) = values().find { it.value == value } ?: NOT_ENCRYPTED
    }
}

data class SubgroupState(
    val bisSync: Long,  // 32-bit bitmask
    val metadataLength: Int,
    val metadata: ByteArray
)

class BassGattManager(
    private val context: Context
) {
    private var bluetoothGatt: BluetoothGatt? = null
    private var basControlPoint: BluetoothGattCharacteristic? = null
    private var receiveStateCharacteristics = mutableListOf<BluetoothGattCharacteristic>()
    
    private val _state = MutableStateFlow<BassState>(BassState.Disconnected)
    val state: StateFlow<BassState> = _state.asStateFlow()
    
    private val _receiveStates = MutableStateFlow<List<BroadcastReceiveState>>(emptyList())
    val receiveStates: StateFlow<List<BroadcastReceiveState>> = _receiveStates.asStateFlow()

    private val pendingWrites = ConcurrentHashMap<Int, CompletableDeferred<Boolean>>()
    private var writeRequestId = 0

    private val gattCallback = object : BluetoothGattCallback() {
        override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {
            when (newState) {
                BluetoothProfile.STATE_CONNECTED -> {
                    _state.value = BassState.Connecting
                    gatt.discoverServices()
                }
                BluetoothProfile.STATE_DISCONNECTED -> {
                    _state.value = BassState.Disconnected
                    cleanup()
                }
            }
        }

        override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {
            if (status != BluetoothGatt.GATT_SUCCESS) {
                _state.value = BassState.Error("Service discovery failed: $status")
                return
            }

            val bassService = gatt.getService(BluetoothUuids.BASS_SERVICE)
            if (bassService == null) {
                _state.value = BassState.Error("BASS service not found on device")
                return
            }

            // Get Control Point
            basControlPoint = bassService.getCharacteristic(
                BluetoothUuids.BROADCAST_AUDIO_SCAN_CONTROL_POINT
            )

            // Get all Broadcast Receive State characteristics
            receiveStateCharacteristics.clear()
            bassService.characteristics.forEach { char ->
                if (char.uuid == BluetoothUuids.BROADCAST_RECEIVE_STATE) {
                    receiveStateCharacteristics.add(char)
                    enableNotifications(gatt, char)
                }
            }

            _state.value = BassState.Connected
        }

        override fun onCharacteristicChanged(
            gatt: BluetoothGatt,
            characteristic: BluetoothGattCharacteristic,
            value: ByteArray
        ) {
            if (characteristic.uuid == BluetoothUuids.BROADCAST_RECEIVE_STATE) {
                parseReceiveState(value)?.let { newState ->
                    val currentStates = _receiveStates.value.toMutableList()
                    val existingIndex = currentStates.indexOfFirst { 
                        it.sourceId == newState.sourceId 
                    }
                    if (existingIndex >= 0) {
                        currentStates[existingIndex] = newState
                    } else {
                        currentStates.add(newState)
                    }
                    _receiveStates.value = currentStates
                    
                    // Update state based on sync status
                    if (newState.paSyncState == PaSyncState.SYNCED) {
                        val syncedBis = newState.subgroups
                            .flatMapIndexed { idx, sg -> 
                                (0..30).filter { (sg.bisSync and (1L shl it)) != 0L }
                                    .map { it + 1 }
                            }
                        _state.value = BassState.Synced(newState.sourceId, syncedBis)
                    }
                }
            }
        }

        override fun onCharacteristicWrite(
            gatt: BluetoothGatt,
            characteristic: BluetoothGattCharacteristic,
            status: Int
        ) {
            val success = status == BluetoothGatt.GATT_SUCCESS
            pendingWrites.values.firstOrNull()?.complete(success)
        }
    }

    fun connect(device: BluetoothDevice): Boolean {
        _state.value = BassState.Connecting
        bluetoothGatt = device.connectGatt(
            context,
            false,
            gattCallback,
            BluetoothDevice.TRANSPORT_LE
        )
        return bluetoothGatt != null
    }

    suspend fun addSource(
        broadcast: DiscoveredBroadcast,
        paSyncEnabled: Boolean = true,
        bisIndices: List<Int> = listOf(1),  // Default: first BIS
        broadcastCode: ByteArray? = null
    ): Result<Int> = withContext(Dispatchers.IO) {
        val controlPoint = basControlPoint 
            ?: return@withContext Result.failure(Exception("Not connected to BASS"))
        
        val gatt = bluetoothGatt 
            ?: return@withContext Result.failure(Exception("GATT not available"))

        // Build Add Source command
        val command = buildAddSourceCommand(
            broadcast = broadcast,
            paSyncEnabled = paSyncEnabled,
            bisIndices = bisIndices
        )

        val deferred = CompletableDeferred<Boolean>()
        pendingWrites[++writeRequestId] = deferred

        controlPoint.value = command
        controlPoint.writeType = BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT
        
        if (!gatt.writeCharacteristic(controlPoint)) {
            pendingWrites.remove(writeRequestId)
            return@withContext Result.failure(Exception("Failed to write to control point"))
        }

        val success = withTimeoutOrNull(5000) { deferred.await() } ?: false
        pendingWrites.remove(writeRequestId)

        if (success) {
            // Source IDã¯æ¬¡ã®Receive State notificationã§å–å¾—
            Result.success(0)
        } else {
            Result.failure(Exception("Add source operation failed"))
        }
    }

    suspend fun setBroadcastCode(sourceId: Int, code: ByteArray): Result<Unit> = 
        withContext(Dispatchers.IO) {
            val controlPoint = basControlPoint 
                ?: return@withContext Result.failure(Exception("Not connected"))
            
            val gatt = bluetoothGatt 
                ?: return@withContext Result.failure(Exception("GATT not available"))

            // Opcode 0x04: Set Broadcast_Code
            val command = ByteArray(18).apply {
                this[0] = 0x04  // Set Broadcast_Code opcode
                this[1] = sourceId.toByte()
                code.copyInto(this, 2, 0, minOf(code.size, 16))
            }

            val deferred = CompletableDeferred<Boolean>()
            pendingWrites[++writeRequestId] = deferred

            controlPoint.value = command
            if (!gatt.writeCharacteristic(controlPoint)) {
                pendingWrites.remove(writeRequestId)
                return@withContext Result.failure(Exception("Failed to write broadcast code"))
            }

            val success = withTimeoutOrNull(5000) { deferred.await() } ?: false
            pendingWrites.remove(writeRequestId)

            if (success) Result.success(Unit)
            else Result.failure(Exception("Set broadcast code failed"))
        }

    suspend fun removeSource(sourceId: Int): Result<Unit> = withContext(Dispatchers.IO) {
        val controlPoint = basControlPoint 
            ?: return@withContext Result.failure(Exception("Not connected"))
        
        val gatt = bluetoothGatt 
            ?: return@withContext Result.failure(Exception("GATT not available"))

        // Opcode 0x05: Remove Source
        val command = byteArrayOf(0x05, sourceId.toByte())

        val deferred = CompletableDeferred<Boolean>()
        pendingWrites[++writeRequestId] = deferred

        controlPoint.value = command
        if (!gatt.writeCharacteristic(controlPoint)) {
            pendingWrites.remove(writeRequestId)
            return@withContext Result.failure(Exception("Failed to write remove command"))
        }

        val success = withTimeoutOrNull(5000) { deferred.await() } ?: false
        pendingWrites.remove(writeRequestId)

        if (success) {
            _receiveStates.value = _receiveStates.value.filter { it.sourceId != sourceId }
            Result.success(Unit)
        } else {
            Result.failure(Exception("Remove source failed"))
        }
    }

    fun disconnect() {
        bluetoothGatt?.disconnect()
    }

    private fun cleanup() {
        bluetoothGatt?.close()
        bluetoothGatt = null
        basControlPoint = null
        receiveStateCharacteristics.clear()
        _receiveStates.value = emptyList()
    }

    private fun enableNotifications(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic) {
        gatt.setCharacteristicNotification(characteristic, true)
        characteristic.getDescriptor(BluetoothUuids.CCCD)?.let { descriptor ->
            descriptor.value = BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE
            gatt.writeDescriptor(descriptor)
        }
    }

    private fun buildAddSourceCommand(
        broadcast: DiscoveredBroadcast,
        paSyncEnabled: Boolean,
        bisIndices: List<Int>
    ): ByteArray {
        val addressBytes = broadcast.address.split(":")
            .map { it.toInt(16).toByte() }
            .reversed()
            .toByteArray()

        // Calculate BIS_Sync bitmask
        val bisSync = bisIndices.fold(0L) { acc, idx -> acc or (1L shl (idx - 1)) }

        return ByteArray(20).apply {
            var offset = 0
            
            // Opcode: Add Source (0x02)
            this[offset++] = 0x02
            
            // Advertiser_Address_Type
            this[offset++] = broadcast.addressType.toByte()
            
            // Advertiser_Address (6 bytes, little-endian)
            addressBytes.copyInto(this, offset)
            offset += 6
            
            // Advertising_SID
            this[offset++] = broadcast.advertisingSid.toByte()
            
            // Broadcast_ID (3 bytes, little-endian)
            this[offset++] = (broadcast.broadcastId and 0xFF).toByte()
            this[offset++] = ((broadcast.broadcastId shr 8) and 0xFF).toByte()
            this[offset++] = ((broadcast.broadcastId shr 16) and 0xFF).toByte()
            
            // PA_Sync
            this[offset++] = if (paSyncEnabled) 0x01 else 0x00
            
            // PA_Interval (unknown = 0xFFFF)
            this[offset++] = 0xFF.toByte()
            this[offset++] = 0xFF.toByte()
            
            // Num_Subgroups
            this[offset++] = 0x01
            
            // Subgroup[0]: BIS_Sync (4 bytes)
            this[offset++] = (bisSync and 0xFF).toByte()
            this[offset++] = ((bisSync shr 8) and 0xFF).toByte()
            this[offset++] = ((bisSync shr 16) and 0xFF).toByte()
            this[offset++] = ((bisSync shr 24) and 0xFF).toByte()
            
            // Subgroup[0]: Metadata_Length
            this[offset++] = 0x00
        }
    }

    private fun parseReceiveState(data: ByteArray): BroadcastReceiveState? {
        if (data.size < 15) return null
        
        var offset = 0
        
        val sourceId = data[offset++].toInt() and 0xFF
        val addressType = data[offset++].toInt() and 0xFF
        
        val address = (0 until 6).map { 
            String.format("%02X", data[offset + 5 - it]) 
        }.joinToString(":")
        offset += 6
        
        val advSid = data[offset++].toInt() and 0xFF
        
        val broadcastId = (data[offset].toInt() and 0xFF) or
                         ((data[offset + 1].toInt() and 0xFF) shl 8) or
                         ((data[offset + 2].toInt() and 0xFF) shl 16)
        offset += 3
        
        val paSyncState = PaSyncState.fromValue(data[offset++].toInt() and 0xFF)
        val bigEncryption = BigEncryption.fromValue(data[offset++].toInt() and 0xFF)
        
        // Parse subgroups if present
        val subgroups = mutableListOf<SubgroupState>()
        if (offset < data.size) {
            val numSubgroups = data[offset++].toInt() and 0xFF
            repeat(numSubgroups) {
                if (offset + 5 <= data.size) {
                    val bisSync = (data[offset].toLong() and 0xFF) or
                                 ((data[offset + 1].toLong() and 0xFF) shl 8) or
                                 ((data[offset + 2].toLong() and 0xFF) shl 16) or
                                 ((data[offset + 3].toLong() and 0xFF) shl 24)
                    offset += 4
                    
                    val metadataLen = data[offset++].toInt() and 0xFF
                    val metadata = if (metadataLen > 0 && offset + metadataLen <= data.size) {
                        data.copyOfRange(offset, offset + metadataLen).also { offset += metadataLen }
                    } else ByteArray(0)
                    
                    subgroups.add(SubgroupState(bisSync, metadataLen, metadata))
                }
            }
        }

        return BroadcastReceiveState(
            sourceId = sourceId,
            sourceAddress = address,
            sourceAddressType = addressType,
            advertisingSid = advSid,
            broadcastId = broadcastId,
            paSyncState = paSyncState,
            bigEncryption = bigEncryption,
            subgroups = subgroups
        )
    }
}
```

### 5.4 Flutter Method Channel Plugin

```kotlin
// plugins/AuracastPlugin.kt
package com.denon.auracast.plugins

import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothManager
import android.content.Context
import com.denon.auracast.bluetooth.*
import io.flutter.embedding.engine.plugins.FlutterPlugin
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MethodChannel
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.collect

class AuracastPlugin : FlutterPlugin {
    private lateinit var methodChannel: MethodChannel
    private lateinit var scanEventChannel: EventChannel
    private lateinit var stateEventChannel: EventChannel
    
    private lateinit var context: Context
    private lateinit var bluetoothAdapter: BluetoothAdapter
    
    private var scanner: AuracastScanner? = null
    private var bassManager: BassGattManager? = null
    
    private val scope = CoroutineScope(Dispatchers.Main + SupervisorJob())
    private var scanJob: Job? = null

    override fun onAttachedToEngine(binding: FlutterPlugin.FlutterPluginBinding) {
        context = binding.applicationContext
        val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
        bluetoothAdapter = bluetoothManager.adapter
        
        scanner = AuracastScanner(bluetoothAdapter)
        bassManager = BassGattManager(context)

        methodChannel = MethodChannel(binding.binaryMessenger, "com.denon.auracast/method")
        methodChannel.setMethodCallHandler { call, result ->
            when (call.method) {
                "isLeAudioSupported" -> {
                    result.success(isLeAudioSupported())
                }
                "startScan" -> {
                    startScan()
                    result.success(null)
                }
                "stopScan" -> {
                    stopScan()
                    result.success(null)
                }
                "connectToSink" -> {
                    val address = call.argument<String>("address")!!
                    scope.launch {
                        val device = bluetoothAdapter.getRemoteDevice(address)
                        val success = bassManager?.connect(device) ?: false
                        result.success(success)
                    }
                }
                "addSource" -> {
                    val sourceAddress = call.argument<String>("sourceAddress")!!
                    val addressType = call.argument<Int>("addressType") ?: 0
                    val broadcastId = call.argument<Int>("broadcastId")!!
                    val advertisingSid = call.argument<Int>("advertisingSid")!!
                    val broadcastCode = call.argument<ByteArray>("broadcastCode")
                    
                    scope.launch {
                        val broadcast = DiscoveredBroadcast(
                            address = sourceAddress,
                            addressType = addressType,
                            name = null,
                            rssi = 0,
                            broadcastId = broadcastId,
                            advertisingSid = advertisingSid,
                            baseData = null,
                            isEncrypted = broadcastCode != null
                        )
                        
                        bassManager?.addSource(broadcast)?.fold(
                            onSuccess = { result.success(true) },
                            onFailure = { result.error("ADD_SOURCE_FAILED", it.message, null) }
                        )
                    }
                }
                "removeSource" -> {
                    val sourceId = call.argument<Int>("sourceId")!!
                    scope.launch {
                        bassManager?.removeSource(sourceId)?.fold(
                            onSuccess = { result.success(true) },
                            onFailure = { result.error("REMOVE_FAILED", it.message, null) }
                        )
                    }
                }
                "disconnect" -> {
                    bassManager?.disconnect()
                    result.success(null)
                }
                else -> result.notImplemented()
            }
        }

        scanEventChannel = EventChannel(binding.binaryMessenger, "com.denon.auracast/scan")
        scanEventChannel.setStreamHandler(object : EventChannel.StreamHandler {
            private var eventSink: EventChannel.EventSink? = null
            
            override fun onListen(arguments: Any?, events: EventChannel.EventSink?) {
                eventSink = events
                scanJob = scope.launch {
                    scanner?.startScan()?.collect { broadcast ->
                        eventSink?.success(mapOf(
                            "address" to broadcast.address,
                            "addressType" to broadcast.addressType,
                            "name" to broadcast.name,
                            "rssi" to broadcast.rssi,
                            "broadcastId" to broadcast.broadcastId,
                            "advertisingSid" to broadcast.advertisingSid,
                            "isEncrypted" to broadcast.isEncrypted
                        ))
                    }
                }
            }
            
            override fun onCancel(arguments: Any?) {
                scanJob?.cancel()
                eventSink = null
            }
        })

        stateEventChannel = EventChannel(binding.binaryMessenger, "com.denon.auracast/state")
        stateEventChannel.setStreamHandler(object : EventChannel.StreamHandler {
            private var stateJob: Job? = null
            
            override fun onListen(arguments: Any?, events: EventChannel.EventSink?) {
                stateJob = scope.launch {
                    bassManager?.state?.collect { state ->
                        events?.success(when (state) {
                            is BassState.Disconnected -> mapOf("state" to "disconnected")
                            is BassState.Connecting -> mapOf("state" to "connecting")
                            is BassState.Connected -> mapOf("state" to "connected")
                            is BassState.SourceAdded -> mapOf(
                                "state" to "sourceAdded",
                                "sourceId" to state.sourceId
                            )
                            is BassState.Synced -> mapOf(
                                "state" to "synced",
                                "sourceId" to state.sourceId,
                                "bisIndices" to state.bisIndices
                            )
                            is BassState.Error -> mapOf(
                                "state" to "error",
                                "message" to state.message
                            )
                        })
                    }
                }
            }
            
            override fun onCancel(arguments: Any?) {
                stateJob?.cancel()
            }
        })
    }

    override fun onDetachedFromEngine(binding: FlutterPlugin.FlutterPluginBinding) {
        scope.cancel()
        methodChannel.setMethodCallHandler(null)
    }

    private fun isLeAudioSupported(): Boolean {
        return android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU &&
               bluetoothAdapter.isLeAudioBroadcastSourceSupported == 
                   android.bluetooth.BluetoothStatusCodes.FEATURE_SUPPORTED
    }

    private fun startScan() {
        // Scan is started via EventChannel listener
    }

    private fun stopScan() {
        scanJob?.cancel()
        scanner?.stopScan()
    }
}
```

---

## 6. Flutterå®Ÿè£…ã‚³ãƒ¼ãƒ‰

### 6.1 Method Channel (Dartå´)

```dart
// lib/services/auracast_channel.dart
import 'dart:async';
import 'dart:typed_data';
import 'package:flutter/services.dart';

class AuracastChannel {
  static const _methodChannel = MethodChannel('com.denon.auracast/method');
  static const _scanEventChannel = EventChannel('com.denon.auracast/scan');
  static const _stateEventChannel = EventChannel('com.denon.auracast/state');

  Future<bool> isLeAudioSupported() async {
    try {
      return await _methodChannel.invokeMethod<bool>('isLeAudioSupported') ?? false;
    } on PlatformException {
      return false;
    }
  }

  Stream<DiscoveredBroadcast> get scanStream =>
      _scanEventChannel.receiveBroadcastStream().map(
        (event) => DiscoveredBroadcast.fromMap(Map<String, dynamic>.from(event)),
      );

  Stream<BassConnectionState> get stateStream =>
      _stateEventChannel.receiveBroadcastStream().map(
        (event) => BassConnectionState.fromMap(Map<String, dynamic>.from(event)),
      );

  Future<void> startScan() async {
    await _methodChannel.invokeMethod('startScan');
  }

  Future<void> stopScan() async {
    await _methodChannel.invokeMethod('stopScan');
  }

  Future<bool> connectToSink(String address) async {
    return await _methodChannel.invokeMethod<bool>('connectToSink', {
      'address': address,
    }) ?? false;
  }

  Future<bool> addSource({
    required String sourceAddress,
    required int addressType,
    required int broadcastId,
    required int advertisingSid,
    Uint8List? broadcastCode,
  }) async {
    try {
      return await _methodChannel.invokeMethod<bool>('addSource', {
        'sourceAddress': sourceAddress,
        'addressType': addressType,
        'broadcastId': broadcastId,
        'advertisingSid': advertisingSid,
        'broadcastCode': broadcastCode,
      }) ?? false;
    } on PlatformException catch (e) {
      throw AuracastException(e.message ?? 'Failed to add source');
    }
  }

  Future<bool> removeSource(int sourceId) async {
    try {
      return await _methodChannel.invokeMethod<bool>('removeSource', {
        'sourceId': sourceId,
      }) ?? false;
    } on PlatformException catch (e) {
      throw AuracastException(e.message ?? 'Failed to remove source');
    }
  }

  Future<void> disconnect() async {
    await _methodChannel.invokeMethod('disconnect');
  }
}

class DiscoveredBroadcast {
  final String address;
  final int addressType;
  final String? name;
  final int rssi;
  final int broadcastId;
  final int advertisingSid;
  final bool isEncrypted;

  DiscoveredBroadcast({
    required this.address,
    required this.addressType,
    this.name,
    required this.rssi,
    required this.broadcastId,
    required this.advertisingSid,
    required this.isEncrypted,
  });

  factory DiscoveredBroadcast.fromMap(Map<String, dynamic> map) {
    return DiscoveredBroadcast(
      address: map['address'] as String,
      addressType: map['addressType'] as int,
      name: map['name'] as String?,
      rssi: map['rssi'] as int,
      broadcastId: map['broadcastId'] as int,
      advertisingSid: map['advertisingSid'] as int,
      isEncrypted: map['isEncrypted'] as bool,
    );
  }

  String get displayName => name ?? 'Broadcast ${broadcastId.toRadixString(16).toUpperCase()}';
}

sealed class BassConnectionState {
  factory BassConnectionState.fromMap(Map<String, dynamic> map) {
    return switch (map['state']) {
      'disconnected' => BassDisconnected(),
      'connecting' => BassConnecting(),
      'connected' => BassConnected(),
      'sourceAdded' => BassSourceAdded(sourceId: map['sourceId'] as int),
      'synced' => BassSynced(
          sourceId: map['sourceId'] as int,
          bisIndices: List<int>.from(map['bisIndices']),
        ),
      'error' => BassError(message: map['message'] as String),
      _ => BassDisconnected(),
    };
  }
}

class BassDisconnected implements BassConnectionState {}
class BassConnecting implements BassConnectionState {}
class BassConnected implements BassConnectionState {}
class BassSourceAdded implements BassConnectionState {
  final int sourceId;
  BassSourceAdded({required this.sourceId});
}
class BassSynced implements BassConnectionState {
  final int sourceId;
  final List<int> bisIndices;
  BassSynced({required this.sourceId, required this.bisIndices});
}
class BassError implements BassConnectionState {
  final String message;
  BassError({required this.message});
}

class AuracastException implements Exception {
  final String message;
  AuracastException(this.message);
  
  @override
  String toString() => 'AuracastException: $message';
}
```

### 6.2 Riverpod Provider

```dart
// lib/presentation/providers/auracast_provider.dart
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../services/auracast_channel.dart';

part 'auracast_provider.g.dart';

@riverpod
AuracastChannel auracastChannel(Ref ref) => AuracastChannel();

@riverpod
class AuracastNotifier extends _$AuracastNotifier {
  StreamSubscription? _scanSubscription;
  StreamSubscription? _stateSubscription;

  @override
  AuracastState build() {
    ref.onDispose(() {
      _scanSubscription?.cancel();
      _stateSubscription?.cancel();
    });
    
    _listenToState();
    return const AuracastState();
  }

  void _listenToState() {
    final channel = ref.read(auracastChannelProvider);
    _stateSubscription = channel.stateStream.listen((bassState) {
      state = state.copyWith(connectionState: bassState);
    });
  }

  Future<void> checkSupport() async {
    final channel = ref.read(auracastChannelProvider);
    final supported = await channel.isLeAudioSupported();
    state = state.copyWith(isSupported: supported);
  }

  Future<void> startScanning() async {
    final channel = ref.read(auracastChannelProvider);
    
    state = state.copyWith(
      isScanning: true,
      discoveredBroadcasts: [],
    );

    _scanSubscription = channel.scanStream.listen(
      (broadcast) {
        final existing = state.discoveredBroadcasts;
        final index = existing.indexWhere((b) => b.address == broadcast.address);
        
        final updated = index >= 0
            ? [...existing]..[index] = broadcast
            : [...existing, broadcast];
        
        // Sort by RSSI (strongest first)
        updated.sort((a, b) => b.rssi.compareTo(a.rssi));
        
        state = state.copyWith(discoveredBroadcasts: updated);
      },
      onError: (error) {
        state = state.copyWith(
          isScanning: false,
          error: error.toString(),
        );
      },
    );
  }

  Future<void> stopScanning() async {
    final channel = ref.read(auracastChannelProvider);
    await channel.stopScan();
    _scanSubscription?.cancel();
    state = state.copyWith(isScanning: false);
  }

  Future<void> connectToSink(String sinkAddress) async {
    final channel = ref.read(auracastChannelProvider);
    state = state.copyWith(connectedSinkAddress: sinkAddress);
    await channel.connectToSink(sinkAddress);
  }

  Future<void> addSourceToSink(DiscoveredBroadcast broadcast) async {
    final channel = ref.read(auracastChannelProvider);
    
    try {
      await channel.addSource(
        sourceAddress: broadcast.address,
        addressType: broadcast.addressType,
        broadcastId: broadcast.broadcastId,
        advertisingSid: broadcast.advertisingSid,
      );
      state = state.copyWith(currentBroadcast: broadcast);
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  Future<void> removeCurrentSource() async {
    final channel = ref.read(auracastChannelProvider);
    final currentState = state.connectionState;
    
    if (currentState is BassSynced) {
      await channel.removeSource(currentState.sourceId);
      state = state.copyWith(currentBroadcast: null);
    }
  }

  Future<void> disconnect() async {
    final channel = ref.read(auracastChannelProvider);
    await channel.disconnect();
    state = state.copyWith(
      connectedSinkAddress: null,
      currentBroadcast: null,
    );
  }
}

class AuracastState {
  final bool isSupported;
  final bool isScanning;
  final List<DiscoveredBroadcast> discoveredBroadcasts;
  final String? connectedSinkAddress;
  final DiscoveredBroadcast? currentBroadcast;
  final BassConnectionState connectionState;
  final String? error;

  const AuracastState({
    this.isSupported = false,
    this.isScanning = false,
    this.discoveredBroadcasts = const [],
    this.connectedSinkAddress,
    this.currentBroadcast,
    this.connectionState = const _InitialBassState(),
    this.error,
  });

  AuracastState copyWith({
    bool? isSupported,
    bool? isScanning,
    List<DiscoveredBroadcast>? discoveredBroadcasts,
    String? connectedSinkAddress,
    DiscoveredBroadcast? currentBroadcast,
    BassConnectionState? connectionState,
    String? error,
  }) {
    return AuracastState(
      isSupported: isSupported ?? this.isSupported,
      isScanning: isScanning ?? this.isScanning,
      discoveredBroadcasts: discoveredBroadcasts ?? this.discoveredBroadcasts,
      connectedSinkAddress: connectedSinkAddress ?? this.connectedSinkAddress,
      currentBroadcast: currentBroadcast ?? this.currentBroadcast,
      connectionState: connectionState ?? this.connectionState,
      error: error,
    );
  }
}

class _InitialBassState implements BassConnectionState {
  const _InitialBassState();
}
```

---

## 7. pubspec.yaml

```yaml
name: denon_auracast
description: Denon TWS Auracast Assistant App
version: 1.0.0+1

environment:
  sdk: '>=3.2.0 <4.0.0'

dependencies:
  flutter:
    sdk: flutter
  
  # State Management
  flutter_riverpod: ^2.5.1
  riverpod_annotation: ^2.3.5
  
  # Local Storage
  hive: ^2.2.3
  hive_flutter: ^1.1.0
  flutter_secure_storage: ^9.2.2
  
  # AWS Amplify
  amplify_flutter: ^2.0.0
  amplify_auth_cognito: ^2.0.0
  amplify_api: ^2.0.0
  
  # Permissions
  permission_handler: ^11.3.1
  
  # UI
  google_fonts: ^6.2.1
  
  # Utilities
  equatable: ^2.0.5
  uuid: ^4.4.2

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0
  build_runner: ^2.4.9
  riverpod_generator: ^2.4.0
  hive_generator: ^2.0.1

flutter:
  uses-material-design: true
```

---

## 8. DynamoDB ãƒ†ãƒ¼ãƒ–ãƒ«è¨­è¨ˆï¼ˆSingle-Table Designï¼‰

### 8.1 ãƒ†ãƒ¼ãƒ–ãƒ«ã‚¹ã‚­ãƒ¼ãƒ

```
Table Name: auracast-main
Region: ap-northeast-1

Primary Key:
  - PK (Partition Key): String
  - SK (Sort Key): String

Global Secondary Indexes:
  - GSI1: GSI1PK (PK), GSI1SK (SK) - ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ¥ã‚¯ã‚¨ãƒªç”¨
  - GSI2: GSI2PK (PK), GSI2SK (SK) - ä½ç½®æƒ…å ±æ¤œç´¢ç”¨

Billing Mode: PAY_PER_REQUEST (On-Demand)
Point-in-Time Recovery: Enabled
```

### 8.2 ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PK             â”‚ SK                      â”‚ Attributes                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ USER#12345     â”‚ PROFILE                 â”‚ name, email, createdAt           â”‚
â”‚ USER#12345     â”‚ DEVICE#dev_001          â”‚ deviceType, name, lastSeen       â”‚
â”‚ USER#12345     â”‚ FAVORITE#bc_001         â”‚ broadcastId, addedAt             â”‚
â”‚ USER#12345     â”‚ HISTORY#2024-12-18      â”‚ broadcastId, duration, timestamp â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ BROADCAST#bc_001â”‚ META                   â”‚ name, language, quality, locationâ”‚
â”‚ BROADCAST#bc_001â”‚ SCHEDULE#2024-12-18   â”‚ startTime, endTime, description  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ VENUE#venue_001â”‚ META                    â”‚ name, address, coordinates       â”‚
â”‚ VENUE#venue_001â”‚ BROADCAST#bc_001       â”‚ broadcastId, position, active    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 9. å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### Phase 1: åŸºç›¤æ§‹ç¯‰ï¼ˆWeek 1-2ï¼‰
- [ ] Flutter ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆæœŸåŒ–
- [ ] Android Method Channel ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
- [ ] AWS CDK ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£æ§‹ç¯‰
- [ ] Cognito ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼è¨­å®š
- [ ] DynamoDB ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ

### Phase 2: Bluetoothå®Ÿè£…ï¼ˆWeek 3-4ï¼‰
- [ ] AuracastScannerå®Ÿè£…ï¼ˆBluetoothLeScanner + ScanFilterï¼‰
- [ ] BassGattManagerå®Ÿè£…ï¼ˆBASS GATTæ“ä½œï¼‰
- [ ] Add Source / Remove Sourceæ“ä½œ
- [ ] Broadcast Receive Stateç›£è¦–
- [ ] Flutter Providerçµ±åˆ

### Phase 3: ã‚³ã‚¢æ©Ÿèƒ½ï¼ˆWeek 5-6ï¼‰
- [ ] ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆä¸€è¦§UI
- [ ] æ¥ç¶šãƒ»åˆ‡æ–­ãƒ•ãƒ­ãƒ¼
- [ ] ãŠæ°—ã«å…¥ã‚Šä¿å­˜æ©Ÿèƒ½
- [ ] ãƒªã‚¹ãƒ‹ãƒ³ã‚°å±¥æ­´

### Phase 4: é«˜åº¦ãªæ©Ÿèƒ½ï¼ˆWeek 7-8ï¼‰
- [ ] Broadcast Codeå…¥åŠ›UIï¼ˆæš—å·åŒ–æ”¾é€å¯¾å¿œï¼‰
- [ ] è¤‡æ•°BISé¸æŠUI
- [ ] AppSync ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸ
- [ ] Kinesis ã‚¤ãƒ™ãƒ³ãƒˆåé›†

### Phase 5: ãƒªãƒªãƒ¼ã‚¹æº–å‚™ï¼ˆWeek 9-10ï¼‰
- [ ] CI/CD ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Œæˆ
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
- [ ] Play Store ç”³è«‹æº–å‚™

---

## 10. é‡è¦ãªè€ƒæ…®äº‹é …

### 10.1 æŠ€è¡“çš„åˆ¶ç´„

1. **Extended Advertisingå¿…é ˆ**: `ScanSettings.setLegacy(false)` ã‚’è¨­å®šã—ãªã„ã¨Auracastæ”¾é€ã‚’æ¤œå‡ºã§ããªã„

2. **PA Syncåˆ¶é™**: ã‚¢ãƒ—ãƒªãƒ¬ãƒ™ãƒ«ã§ã¯PAï¼ˆPeriodic Advertisingï¼‰Syncã‚’ç›´æ¥åˆ¶å¾¡ã§ããªã„ã€‚ã‚¤ãƒ¤ãƒ›ãƒ³å´ã®BASSãŒPA Syncã‚’ç®¡ç†ã™ã‚‹

3. **BIG Syncåˆ¶é™**: åŒæ§˜ã«BIG Syncã‚‚ã‚¤ãƒ¤ãƒ›ãƒ³å´ã§ç®¡ç†ã€‚ã‚¢ãƒ—ãƒªã¯BASSçµŒç”±ã§æŒ‡ç¤ºã‚’å‡ºã™ã®ã¿

### 10.2 äº’æ›æ€§ãƒãƒˆãƒªã‚¯ã‚¹

| TWSå´è¦ä»¶ | èª¬æ˜ |
|-----------|------|
| BASS GATT Service | ã‚¤ãƒ¤ãƒ›ãƒ³ãŒBASSã‚’å…¬é–‹ã—ã¦ã„ã‚‹ã“ã¨ |
| LE Audio Sink | Broadcast Sinkæ©Ÿèƒ½å¯¾å¿œ |
| PA Syncå¯¾å¿œ | Periodic Advertisingå—ä¿¡å¯èƒ½ |

### 10.3 ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

- Broadcast Codeã¯`flutter_secure_storage`ã§æš—å·åŒ–ä¿å­˜
- AWS Secrets Managerã§æœ¬ç•ªAPIã‚­ãƒ¼ç®¡ç†
- GATTé€šä¿¡ã¯BLEæš—å·åŒ–ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ä¿è­·

### 10.4 ãƒ‡ãƒãƒƒã‚°Tips

```bash
# Android BLE HCI snoop logæœ‰åŠ¹åŒ–
adb shell settings put secure bluetooth_hci_log 1
# å†èµ·å‹•å¾Œã€/data/misc/bluetooth/logs/ ã§ãƒ­ã‚°å–å¾—

# GATTæ“ä½œç¢ºèª
adb logcat -s "BluetoothGatt"
```

---

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€Airoha SDKã«ä¾å­˜ã›ãšã€Androidæ¨™æº–BLE APIã¨ã‚¤ãƒ¤ãƒ›ãƒ³å´BASS GATTã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ç”¨ã—ãŸã‚¢ãƒ—ãƒªå†…å®Œçµã®Auracast Assistantå®Ÿè£…ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚
